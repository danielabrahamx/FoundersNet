#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 2
    bytecblock "event_counter" 0x151f7c75 "bet_counter" "events" 0x00 "admin" 0x0000 "bets" "event_bets" "user_bets"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/prediction_market.py:60-61
    // # Global state variables
    // self.admin = Account()
    bytec 5 // "admin"
    global ZeroAddress
    app_global_put
    // smart_contracts/prediction_market.py:62
    // self.event_counter = UInt64(0)
    bytec_0 // "event_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/prediction_market.py:63
    // self.bet_counter = UInt64(0)
    bytec_2 // "bet_counter"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/prediction_market.py:47
    // class PredictionMarket(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@19
    pushbytess 0xdba3036e 0x6f71d111 0xbb54b524 0x7b37dfda 0xa365fd51 0x0c237eda 0xe437dd73 0x788d5cf9 0x17ab816e 0xa2ebc461 0x346b3dbc 0xa6ed4cc3 0x1ef5e8d5 // method "create_event(string,uint64)uint64", method "place_bet(uint64,bool,pay)void", method "resolve_event(uint64,bool)void", method "claim_winnings(uint64)void", method "get_user_bets(address)(uint64,uint64,address,bool,uint64,bool)[]", method "get_total_bets(uint64)(uint64,uint64)", method "get_event(uint64)(uint64,string,uint64,bool,bool,uint64,uint64,uint64,uint64)", method "get_all_events()(uint64,string,uint64,bool,bool,uint64,uint64,uint64,uint64)[]", method "get_contract_balance()uint64", method "emergency_withdraw()void", method "get_admin()address", method "get_event_counter()uint64", method "get_bet_counter()uint64"
    txna ApplicationArgs 0
    match create_event place_bet resolve_event claim_winnings get_user_bets get_total_bets get_event get_all_events get_contract_balance emergency_withdraw get_admin get_event_counter get_bet_counter
    err

main_create_NoOp@19:
    // smart_contracts/prediction_market.py:47
    // class PredictionMarket(ARC4Contract):
    pushbytes 0x894a716e // method "create_application(address)void"
    txna ApplicationArgs 0
    match create_application
    err


// prediction_market.PredictionMarket.create_application[routing]() -> void:
create_application:
    // smart_contracts/prediction_market.py:71
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/prediction_market.py:80
    // self.admin = admin
    bytec 5 // "admin"
    swap
    app_global_put
    // smart_contracts/prediction_market.py:81
    // self.event_counter = UInt64(0)
    bytec_0 // "event_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/prediction_market.py:82
    // self.bet_counter = UInt64(0)
    bytec_2 // "bet_counter"
    intc_0 // 0
    app_global_put
    // smart_contracts/prediction_market.py:71
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// prediction_market.PredictionMarket.create_event[routing]() -> void:
create_event:
    // smart_contracts/prediction_market.py:84
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+utf8[])
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/prediction_market.py:100-101
    // # Only admin can create events
    // assert Txn.sender == self.admin, "Only admin can create events"
    txn Sender
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can create events
    // smart_contracts/prediction_market.py:103-104
    // # Validate end time is in the future
    // assert end_time.native > Global.latest_timestamp, "End time must be in the future"
    dup
    btoi
    global LatestTimestamp
    >
    assert // End time must be in the future
    // smart_contracts/prediction_market.py:106-107
    // # Increment event counter
    // self.event_counter += UInt64(1)
    intc_0 // 0
    bytec_0 // "event_counter"
    app_global_get_ex
    assert // check self.event_counter exists
    intc_1 // 1
    +
    bytec_0 // "event_counter"
    dig 1
    app_global_put
    // smart_contracts/prediction_market.py:112
    // event_id=arc4.UInt64(current_event_id),
    itob
    // smart_contracts/prediction_market.py:110-121
    // # Create new event struct
    // new_event = EventStruct(
    //     event_id=arc4.UInt64(current_event_id),
    //     name=name,
    //     end_time=end_time,
    //     resolved=arc4.Bool(False),
    //     outcome=arc4.Bool(False),
    //     total_yes_bets=arc4.UInt64(0),
    //     total_no_bets=arc4.UInt64(0),
    //     total_yes_amount=arc4.UInt64(0),
    //     total_no_amount=arc4.UInt64(0),
    // )
    dup
    pushbytes 0x0033
    concat
    uncover 2
    concat
    pushbytes 0x000000000000000000000000000000000000000000000000000000000000000000
    concat
    uncover 2
    concat
    // smart_contracts/prediction_market.py:123-124
    // # Store event in box storage
    // self.events[arc4.UInt64(current_event_id)] = new_event.copy()
    bytec_3 // "events"
    dig 2
    concat
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/prediction_market.py:126-127
    // # Initialize empty bet array for this event
    // self.event_bets[arc4.UInt64(current_event_id)] = arc4.DynamicArray[arc4.UInt64]()
    bytec 8 // "event_bets"
    dig 1
    concat
    dup
    box_del
    pop
    bytec 6 // 0x0000
    box_put
    // smart_contracts/prediction_market.py:129-130
    // # Log event creation (via transaction note)
    // log(arc4.String("EventCreated").bytes + arc4.UInt64(current_event_id).bytes)
    pushbytes 0x000c4576656e7443726561746564
    dig 1
    concat
    log
    // smart_contracts/prediction_market.py:84
    // @arc4.abimethod
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.place_bet[routing]() -> void:
place_bet:
    // smart_contracts/prediction_market.py:134
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/prediction_market.py:159-160
    // # Validate event exists
    // assert event_id.native <= self.event_counter, "Event does not exist"
    dig 2
    btoi
    intc_0 // 0
    bytec_0 // "event_counter"
    app_global_get_ex
    assert // check self.event_counter exists
    <=
    assert // Event does not exist
    // smart_contracts/prediction_market.py:162-163
    // # Get event from storage
    // event = self.events[event_id].copy()
    bytec_3 // "events"
    dig 3
    concat
    dup
    cover 4
    dup
    box_get
    swap
    cover 5
    assert // check self.events entry exists
    // smart_contracts/prediction_market.py:165-166
    // # Validate event is not resolved
    // assert not event.resolved.native, "Event is already resolved"
    dup
    pushint 18 // 18
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    !
    assert // Event is already resolved
    // smart_contracts/prediction_market.py:168-169
    // # Validate betting period hasn't ended
    // assert Global.latest_timestamp < event.end_time.native, "Event betting period has ended"
    global LatestTimestamp
    swap
    pushint 10 // 10
    intc_2 // 8
    box_extract
    btoi
    <
    assert // Event betting period has ended
    // smart_contracts/prediction_market.py:171-172
    // # Validate payment
    // assert payment.amount > 0, "Bet amount must be greater than 0"
    dup
    gtxns Amount
    dup
    cover 4
    dup
    assert // Bet amount must be greater than 0
    // smart_contracts/prediction_market.py:173
    // assert payment.receiver == Global.current_application_address, "Payment must be to app account"
    swap
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be to app account
    // smart_contracts/prediction_market.py:175-176
    // # Increment bet counter
    // self.bet_counter += UInt64(1)
    intc_0 // 0
    bytec_2 // "bet_counter"
    app_global_get_ex
    assert // check self.bet_counter exists
    intc_1 // 1
    +
    bytec_2 // "bet_counter"
    dig 1
    app_global_put
    // smart_contracts/prediction_market.py:181
    // bet_id=arc4.UInt64(current_bet_id),
    itob
    dup
    cover 4
    // smart_contracts/prediction_market.py:183
    // bettor=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/prediction_market.py:185
    // amount=arc4.UInt64(payment.amount),
    uncover 2
    itob
    // smart_contracts/prediction_market.py:179-187
    // # Create new bet struct
    // new_bet = BetStruct(
    //     bet_id=arc4.UInt64(current_bet_id),
    //     event_id=event_id,
    //     bettor=arc4.Address(Txn.sender),
    //     outcome=outcome,
    //     amount=arc4.UInt64(payment.amount),
    //     claimed=arc4.Bool(False),
    // )
    dig 2
    uncover 5
    concat
    uncover 2
    concat
    uncover 3
    concat
    swap
    concat
    // smart_contracts/prediction_market.py:186
    // claimed=arc4.Bool(False),
    bytec 4 // 0x00
    // smart_contracts/prediction_market.py:179-187
    // # Create new bet struct
    // new_bet = BetStruct(
    //     bet_id=arc4.UInt64(current_bet_id),
    //     event_id=event_id,
    //     bettor=arc4.Address(Txn.sender),
    //     outcome=outcome,
    //     amount=arc4.UInt64(payment.amount),
    //     claimed=arc4.Bool(False),
    // )
    concat
    // smart_contracts/prediction_market.py:189-190
    // # Store bet in box storage
    // self.bets[arc4.UInt64(current_bet_id)] = new_bet.copy()
    bytec 7 // "bets"
    uncover 2
    concat
    swap
    box_put
    // smart_contracts/prediction_market.py:194
    // if bettor_address in self.user_bets:
    bytec 9 // "user_bets"
    // smart_contracts/prediction_market.py:192-193
    // # Update user bets array
    // bettor_address = arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/prediction_market.py:194
    // if bettor_address in self.user_bets:
    concat
    dup
    box_len
    bury 1
    bz place_bet_else_body@3
    // smart_contracts/prediction_market.py:195
    // user_bet_list = self.user_bets[bettor_address].copy()
    dup
    box_get
    assert // check self.user_bets entry exists
    // smart_contracts/prediction_market.py:196
    // user_bet_list.append(arc4.UInt64(current_bet_id))
    dup
    dig 3
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    // smart_contracts/prediction_market.py:197
    // self.user_bets[bettor_address] = user_bet_list.copy()
    dig 1
    box_del
    pop
    box_put

place_bet_after_if_else@4:
    // smart_contracts/prediction_market.py:202-203
    // # Update event bets array
    // event_bet_list = self.event_bets[event_id].copy()
    bytec 8 // "event_bets"
    dig 6
    concat
    dup
    box_get
    assert // check self.event_bets entry exists
    // smart_contracts/prediction_market.py:204
    // event_bet_list.append(arc4.UInt64(current_bet_id))
    dup
    dig 3
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    // smart_contracts/prediction_market.py:205
    // self.event_bets[event_id] = event_bet_list.copy()
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/prediction_market.py:207-208
    // # Update event totals
    // if outcome.native:
    dig 4
    intc_0 // 0
    getbit
    bz place_bet_else_body@6
    // smart_contracts/prediction_market.py:209
    // event.total_yes_bets = arc4.UInt64(event.total_yes_bets.native + 1)
    dig 3
    pushint 19 // 19
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    +
    itob
    dig 3
    swap
    replace2 19
    // smart_contracts/prediction_market.py:210
    // event.total_yes_amount = arc4.UInt64(event.total_yes_amount.native + payment.amount)
    dup
    pushint 35 // 35
    extract_uint64
    dig 3
    +
    itob
    replace2 35
    bury 3

place_bet_after_if_else@7:
    // smart_contracts/prediction_market.py:215-216
    // # Update event in storage
    // self.events[event_id] = event.copy()
    dig 3
    dup
    box_del
    pop
    dig 3
    box_put
    // smart_contracts/prediction_market.py:218-219
    // # Log bet placement
    // log(arc4.String("BetPlaced").bytes + arc4.UInt64(current_bet_id).bytes)
    pushbytes 0x0009426574506c61636564
    dig 1
    concat
    log
    // smart_contracts/prediction_market.py:134
    // @arc4.abimethod
    intc_1 // 1
    return

place_bet_else_body@6:
    // smart_contracts/prediction_market.py:212
    // event.total_no_bets = arc4.UInt64(event.total_no_bets.native + 1)
    dig 3
    pushint 27 // 27
    intc_2 // 8
    box_extract
    btoi
    intc_1 // 1
    +
    itob
    dig 3
    swap
    replace2 27
    // smart_contracts/prediction_market.py:213
    // event.total_no_amount = arc4.UInt64(event.total_no_amount.native + payment.amount)
    dup
    pushint 43 // 43
    extract_uint64
    dig 3
    +
    itob
    replace2 43
    bury 3
    b place_bet_after_if_else@7

place_bet_else_body@3:
    // smart_contracts/prediction_market.py:199
    // new_list = arc4.DynamicArray[arc4.UInt64](arc4.UInt64(current_bet_id))
    pushbytes 0x0001
    dig 2
    concat
    // smart_contracts/prediction_market.py:200
    // self.user_bets[bettor_address] = new_list.copy()
    swap
    dup
    box_del
    pop
    swap
    box_put
    b place_bet_after_if_else@4


// prediction_market.PredictionMarket.resolve_event[routing]() -> void:
resolve_event:
    // smart_contracts/prediction_market.py:221
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for bool8
    // smart_contracts/prediction_market.py:236-237
    // # Only admin can resolve events
    // assert Txn.sender == self.admin, "Only admin can resolve events"
    txn Sender
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can resolve events
    // smart_contracts/prediction_market.py:239-240
    // # Validate event exists
    // assert event_id.native <= self.event_counter, "Event does not exist"
    dig 1
    btoi
    intc_0 // 0
    bytec_0 // "event_counter"
    app_global_get_ex
    assert // check self.event_counter exists
    <=
    assert // Event does not exist
    // smart_contracts/prediction_market.py:242-243
    // # Get event from storage
    // event = self.events[event_id].copy()
    bytec_3 // "events"
    dig 2
    concat
    dup
    box_get
    assert // check self.events entry exists
    // smart_contracts/prediction_market.py:245-246
    // # Validate event is not already resolved
    // assert not event.resolved.native, "Event already resolved"
    dig 1
    pushint 18 // 18
    intc_1 // 1
    box_extract
    intc_0 // 0
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    !
    assert // Event already resolved
    // smart_contracts/prediction_market.py:248-249
    // # Update event resolution
    // event.resolved = arc4.Bool(True)
    pushint 144 // 144
    intc_1 // 1
    setbit
    // smart_contracts/prediction_market.py:250
    // event.outcome = outcome
    uncover 2
    intc_0 // 0
    getbit
    pushint 145 // 145
    swap
    setbit
    // smart_contracts/prediction_market.py:252-253
    // # Update event in storage
    // self.events[event_id] = event.copy()
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/prediction_market.py:255-256
    // # Log event resolution
    // log(arc4.String("EventResolved").bytes + event_id.bytes)
    pushbytes 0x000d4576656e745265736f6c766564
    swap
    concat
    log
    // smart_contracts/prediction_market.py:221
    // @arc4.abimethod
    intc_1 // 1
    return


// prediction_market.PredictionMarket.claim_winnings[routing]() -> void:
claim_winnings:
    // smart_contracts/prediction_market.py:258
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/prediction_market.py:274-275
    // # Validate bet exists
    // assert bet_id.native <= self.bet_counter, "Bet does not exist"
    dup
    btoi
    intc_0 // 0
    bytec_2 // "bet_counter"
    app_global_get_ex
    assert // check self.bet_counter exists
    <=
    assert // Bet does not exist
    // smart_contracts/prediction_market.py:277-278
    // # Get bet from storage
    // bet = self.bets[bet_id].copy()
    bytec 7 // "bets"
    swap
    concat
    dup
    box_get
    swap
    dup
    uncover 2
    assert // check self.bets entry exists
    // smart_contracts/prediction_market.py:280-281
    // # Validate caller is the bettor
    // assert Txn.sender == bet.bettor.native, "Not the bet owner"
    txn Sender
    dig 1
    extract 16 32
    ==
    assert // Not the bet owner
    // smart_contracts/prediction_market.py:283-284
    // # Validate not already claimed
    // assert not bet.claimed.native, "Winnings already claimed"
    dup
    pushint 456 // 456
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    !
    assert // Winnings already claimed
    // smart_contracts/prediction_market.py:286-287
    // # Get event from storage
    // event = self.events[bet.event_id].copy()
    dup
    extract 8 8
    bytec_3 // "events"
    swap
    concat
    // smart_contracts/prediction_market.py:289-290
    // # Validate event is resolved
    // assert event.resolved.native, "Event not resolved yet"
    dup
    pushint 18 // 18
    intc_1 // 1
    box_extract
    dup
    intc_0 // 0
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    assert // Event not resolved yet
    // smart_contracts/prediction_market.py:292-293
    // # Validate bet won
    // assert bet.outcome.native == event.outcome.native, "Bet did not win"
    uncover 2
    pushint 384 // 384
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    swap
    intc_1 // 1
    getbit
    bytec 4 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    dig 1
    ==
    assert // Bet did not win
    // smart_contracts/prediction_market.py:295-296
    // # Calculate payout
    // total_pool = event.total_yes_amount.native + event.total_no_amount.native
    dig 1
    pushint 35 // 35
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 2
    cover 3
    uncover 2
    pushint 43 // 43
    intc_2 // 8
    box_extract
    btoi
    dup
    cover 3
    uncover 2
    +
    swap
    // smart_contracts/prediction_market.py:297
    // winning_pool = event.total_yes_amount.native if bet.outcome.native else event.total_no_amount.native
    bz claim_winnings_ternary_false@3
    dig 2

claim_winnings_ternary_merge@4:
    // smart_contracts/prediction_market.py:299-300
    // # Proportional payout: (bet_amount * total_pool) / winning_pool
    // payout = (bet.amount.native * total_pool) // winning_pool
    dig 4
    dup
    pushint 49 // 49
    extract_uint64
    dig 3
    *
    uncover 2
    /
    // smart_contracts/prediction_market.py:302-303
    // # Mark bet as claimed
    // bet.claimed = arc4.Bool(True)
    swap
    pushint 456 // 456
    intc_1 // 1
    setbit
    // smart_contracts/prediction_market.py:302-304
    // # Mark bet as claimed
    // bet.claimed = arc4.Bool(True)
    // self.bets[bet_id] = bet.copy()
    dig 6
    dup
    pushint 57 // 57
    intc_1 // 1
    box_extract
    intc_0 // 0
    // smart_contracts/prediction_market.py:302-303
    // # Mark bet as claimed
    // bet.claimed = arc4.Bool(True)
    intc_1 // 1
    // smart_contracts/prediction_market.py:302-304
    // # Mark bet as claimed
    // bet.claimed = arc4.Bool(True)
    // self.bets[bet_id] = bet.copy()
    setbit
    pushint 57 // 57
    swap
    box_replace
    // smart_contracts/prediction_market.py:306-311
    // # Send payout via inner transaction
    // itxn.Payment(
    //     receiver=bet.bettor.native,
    //     amount=payout,
    //     fee=0,  # Use fee pooling from group
    // ).submit()
    itxn_begin
    // smart_contracts/prediction_market.py:308
    // receiver=bet.bettor.native,
    extract 16 32
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/prediction_market.py:306-307
    // # Send payout via inner transaction
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/prediction_market.py:310
    // fee=0,  # Use fee pooling from group
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/prediction_market.py:306-311
    // # Send payout via inner transaction
    // itxn.Payment(
    //     receiver=bet.bettor.native,
    //     amount=payout,
    //     fee=0,  # Use fee pooling from group
    // ).submit()
    itxn_submit
    // smart_contracts/prediction_market.py:313-314
    // # Log winnings claimed
    // log(arc4.String("WinningsClaimed").bytes + bet_id.bytes)
    pushbytes 0x000f57696e6e696e6773436c61696d6564
    dig 6
    concat
    log
    // smart_contracts/prediction_market.py:258
    // @arc4.abimethod
    intc_1 // 1
    return

claim_winnings_ternary_false@3:
    dig 1
    b claim_winnings_ternary_merge@4


// prediction_market.PredictionMarket.get_user_bets[routing]() -> void:
get_user_bets:
    intc_0 // 0
    pushbytes ""
    dup
    // smart_contracts/prediction_market.py:316
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for uint8[32]
    // smart_contracts/prediction_market.py:327
    // result = arc4.DynamicArray[BetStruct]()
    bytec 6 // 0x0000
    swap
    // smart_contracts/prediction_market.py:329
    // if user in self.user_bets:
    bytec 9 // "user_bets"
    swap
    concat
    dup
    box_len
    bury 1
    bz get_user_bets_after_if_else@9
    // smart_contracts/prediction_market.py:330-331
    // bet_ids = self.user_bets[user].copy()
    // for i in urange(bet_ids.length):
    dup
    intc_0 // 0
    intc_3 // 2
    box_extract
    btoi
    bury 4
    // smart_contracts/prediction_market.py:331
    // for i in urange(bet_ids.length):
    intc_0 // 0
    bury 3

get_user_bets_for_header@3:
    // smart_contracts/prediction_market.py:331
    // for i in urange(bet_ids.length):
    dig 2
    dig 4
    <
    bz get_user_bets_after_if_else@9
    // smart_contracts/prediction_market.py:332
    // bet_id = bet_ids[i]
    dig 2
    intc_2 // 8
    *
    intc_3 // 2
    +
    dig 1
    swap
    intc_2 // 8
    box_extract
    dup
    bury 6
    // smart_contracts/prediction_market.py:333
    // if bet_id.native <= self.bet_counter:
    btoi
    intc_0 // 0
    bytec_2 // "bet_counter"
    app_global_get_ex
    assert // check self.bet_counter exists
    <=
    bz get_user_bets_after_if_else@6
    // smart_contracts/prediction_market.py:334
    // bet = self.bets[bet_id].copy()
    bytec 7 // "bets"
    dig 5
    concat
    box_get
    assert // check self.bets entry exists
    // smart_contracts/prediction_market.py:335
    // result.append(bet.copy())
    dig 2
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 2

get_user_bets_after_if_else@6:
    // smart_contracts/prediction_market.py:331
    // for i in urange(bet_ids.length):
    dig 2
    intc_1 // 1
    +
    bury 3
    b get_user_bets_for_header@3

get_user_bets_after_if_else@9:
    // smart_contracts/prediction_market.py:316
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.get_total_bets[routing]() -> void:
get_total_bets:
    // smart_contracts/prediction_market.py:339
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/prediction_market.py:353
    // assert event_id.native <= self.event_counter, "Event does not exist"
    dup
    btoi
    intc_0 // 0
    bytec_0 // "event_counter"
    app_global_get_ex
    assert // check self.event_counter exists
    <=
    assert // Event does not exist
    // smart_contracts/prediction_market.py:355
    // event = self.events[event_id].copy()
    bytec_3 // "events"
    swap
    concat
    // smart_contracts/prediction_market.py:355-356
    // event = self.events[event_id].copy()
    // return arc4.Tuple((event.total_yes_bets, event.total_no_bets))
    dup
    pushint 19 // 19
    intc_2 // 8
    box_extract
    swap
    pushint 27 // 27
    intc_2 // 8
    box_extract
    // smart_contracts/prediction_market.py:356
    // return arc4.Tuple((event.total_yes_bets, event.total_no_bets))
    concat
    // smart_contracts/prediction_market.py:339
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.get_event[routing]() -> void:
get_event:
    // smart_contracts/prediction_market.py:358
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for uint64
    // smart_contracts/prediction_market.py:372
    // assert event_id.native <= self.event_counter, "Event does not exist"
    dup
    btoi
    intc_0 // 0
    bytec_0 // "event_counter"
    app_global_get_ex
    assert // check self.event_counter exists
    <=
    assert // Event does not exist
    // smart_contracts/prediction_market.py:373
    // return self.events[event_id].copy()
    bytec_3 // "events"
    swap
    concat
    box_get
    assert // check self.events entry exists
    // smart_contracts/prediction_market.py:358
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.get_all_events[routing]() -> void:
get_all_events:
    intc_0 // 0
    dupn 2
    pushbytes ""
    dupn 3
    // smart_contracts/prediction_market.py:383
    // result = arc4.DynamicArray[EventStruct]()
    bytec 6 // 0x0000
    // smart_contracts/prediction_market.py:385
    // for i in urange(1, self.event_counter + 1):
    intc_0 // 0
    bytec_0 // "event_counter"
    app_global_get_ex
    assert // check self.event_counter exists
    intc_1 // 1
    +
    intc_1 // 1

get_all_events_for_header@2:
    // smart_contracts/prediction_market.py:385
    // for i in urange(1, self.event_counter + 1):
    dup
    dig 2
    <
    bz get_all_events_after_for@5
    // smart_contracts/prediction_market.py:386
    // event_id = arc4.UInt64(i)
    dup
    itob
    // smart_contracts/prediction_market.py:387
    // event = self.events[event_id].copy()
    bytec_3 // "events"
    swap
    concat
    box_get
    assert // check self.events entry exists
    // smart_contracts/prediction_market.py:388
    // result.append(event.copy())
    dig 3
    dup
    intc_0 // 0
    extract_uint16
    dup
    cover 2
    bury 10
    extract 2 0
    bury 12
    pushbytes 0x0002
    uncover 2
    concat
    bury 9
    pushbytes 0x
    bury 10
    intc_3 // 2
    *
    bury 4
    intc_0 // 0
    bury 5

get_all_events_for_header@7:
    dig 4
    dig 4
    <
    bz get_all_events_after_for@9
    dig 9
    dig 5
    dup
    cover 2
    extract_uint16
    intc_3 // 2
    +
    itob
    extract 6 2
    dig 10
    swap
    concat
    bury 10
    intc_3 // 2
    +
    bury 5
    b get_all_events_for_header@7

get_all_events_after_for@9:
    dig 9
    len
    bury 6
    intc_0 // 0
    bury 5

get_all_events_for_header@10:
    dig 4
    intc_3 // 2
    <
    bz get_all_events_after_for@12
    dig 7
    dig 5
    dup
    cover 2
    extract_uint16
    dig 7
    +
    itob
    extract 6 2
    dig 10
    swap
    concat
    bury 10
    intc_3 // 2
    +
    bury 5
    b get_all_events_for_header@10

get_all_events_after_for@12:
    dig 6
    // smart_contracts/prediction_market.py:388
    // result.append(event.copy())
    intc_1 // 1
    +
    itob
    extract 6 2
    dig 9
    concat
    dig 10
    dig 5
    dig 8
    substring3
    concat
    dig 8
    extract 2 0
    concat
    bury 3
    // smart_contracts/prediction_market.py:385
    // for i in urange(1, self.event_counter + 1):
    dup
    intc_1 // 1
    +
    bury 1
    b get_all_events_for_header@2

get_all_events_after_for@5:
    // smart_contracts/prediction_market.py:375
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    dig 3
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.get_contract_balance[routing]() -> void:
get_contract_balance:
    // smart_contracts/prediction_market.py:400
    // return arc4.UInt64(Global.current_application_address.balance)
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    itob
    // smart_contracts/prediction_market.py:392
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.emergency_withdraw[routing]() -> void:
emergency_withdraw:
    // smart_contracts/prediction_market.py:411-412
    // # Only admin can emergency withdraw
    // assert Txn.sender == self.admin, "Only admin can emergency withdraw"
    txn Sender
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    swap
    dig 1
    ==
    assert // Only admin can emergency withdraw
    // smart_contracts/prediction_market.py:414-415
    // # Get current balance (minus minimum balance requirement)
    // current_balance = Global.current_application_address.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/prediction_market.py:416
    // min_balance = Global.min_balance
    global MinBalance
    // smart_contracts/prediction_market.py:417
    // withdrawal_amount = current_balance - min_balance
    -
    // smart_contracts/prediction_market.py:419
    // assert withdrawal_amount > 0, "No balance to withdraw"
    dup
    assert // No balance to withdraw
    // smart_contracts/prediction_market.py:421-426
    // # Send funds via inner transaction
    // itxn.Payment(
    //     receiver=self.admin,
    //     amount=withdrawal_amount,
    //     fee=0,  # Use fee pooling from group
    // ).submit()
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/prediction_market.py:421-422
    // # Send funds via inner transaction
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/prediction_market.py:425
    // fee=0,  # Use fee pooling from group
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/prediction_market.py:421-426
    // # Send funds via inner transaction
    // itxn.Payment(
    //     receiver=self.admin,
    //     amount=withdrawal_amount,
    //     fee=0,  # Use fee pooling from group
    // ).submit()
    itxn_submit
    // smart_contracts/prediction_market.py:428-429
    // # Log emergency withdrawal
    // log(arc4.String("EmergencyWithdraw").bytes)
    pushbytes 0x0011456d657267656e63795769746864726177
    log
    // smart_contracts/prediction_market.py:402
    // @arc4.abimethod
    intc_1 // 1
    return


// prediction_market.PredictionMarket.get_admin[routing]() -> void:
get_admin:
    // smart_contracts/prediction_market.py:439
    // return arc4.Address(self.admin)
    intc_0 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    // smart_contracts/prediction_market.py:431
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.get_event_counter[routing]() -> void:
get_event_counter:
    // smart_contracts/prediction_market.py:449
    // return arc4.UInt64(self.event_counter)
    intc_0 // 0
    bytec_0 // "event_counter"
    app_global_get_ex
    assert // check self.event_counter exists
    itob
    // smart_contracts/prediction_market.py:441
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// prediction_market.PredictionMarket.get_bet_counter[routing]() -> void:
get_bet_counter:
    // smart_contracts/prediction_market.py:459
    // return arc4.UInt64(self.bet_counter)
    intc_0 // 0
    bytec_2 // "bet_counter"
    app_global_get_ex
    assert // check self.bet_counter exists
    itob
    // smart_contracts/prediction_market.py:451
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
